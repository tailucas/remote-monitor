#!/usr/bin/python
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import signal
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_ADCPi import ADCPi
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from random import randint
from threading import Thread
from time import sleep
from zmq import ContextTerminated

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)
# no console by default
log.propagate = False

ADC_SAMPLE_MAX = 5.0
DEVICE_DEBOUNCE_SECONDS = 60
HEARTBEAT_INTERVAL_SECONDS = 5
RELAY_DEFAULT_ACTIVE_TIME_SECONDS = 1
SAMPLE_INTERVAL_SECONDS = 0.1
SAMPLE_DEVIATION_TOLERANCE = 4
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'
URL_WORKER_RELAY_CTRL = 'inproc://{}'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

zmq_context = zmq.Context()


class Relay(Thread):

    def __init__(self, relay_name, io, pin):
        super(Relay, self).__init__()
        self.daemon = True
        self._name = relay_name
        self._io = io
        self._pin = pin
        self._zmq_url = URL_WORKER_RELAY_CTRL.format(relay_name)
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(self._zmq_url)

    @property
    def zmq_url(self):
        return self._zmq_url

    def run(self):
        while True:
            try:
                relay_ctrl = self.socket.recv_pyobj()
                if 'state' in relay_ctrl:
                    if relay_ctrl['state'] is True:
                        self._io.write_pin(self._pin, 1)
                        # sleep
                        if 'delay' in relay_ctrl:
                            delay = relay_ctrl['delay']
                        else:
                            delay = RELAY_DEFAULT_ACTIVE_TIME_SECONDS
                        log.info("Activating {} for {} seconds.".format(self._name, delay))
                        self._io.write_pin(self._pin, 1)
                        sleep(float(delay))
                    self._io.write_pin(self._pin, 0)
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class RelayControl(Thread):

    def __init__(self, relay_mappings):
        super(RelayControl, self).__init__()
        self.daemon = True
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind('tcp://*:{port}'.format(port=config.get('zmq', 'relay_port')))
        # Push socket to control relays
        self._sockets = dict()
        for relay, worker_url in relay_mappings.items():
            socket = zmq_context.socket(zmq.PUSH)
            self._sockets[relay] = socket
            socket.connect(worker_url)

    def run(self):
        while True:
            try:
                data = umsgpack.unpackb(self.socket.recv())
                log.debug("Relay control '{}'".format(data))
                if 'relays' in data:
                    relays_to_activate = data['relays']
                    for relay in relays_to_activate.keys():
                        if relay in self._sockets:
                            relay_ctrl = relays_to_activate[relay]
                            log.debug('Sending control for {}: [{}]'.format(relay, relay_ctrl))
                            self._sockets[relay].send_pyobj(relay_ctrl)
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        # inproc socket to accept messages to publish
        # to the outside world
        self.inproc_pull = zmq_context.socket(zmq.PULL)
        self.inproc_pull.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                  port=config.get('zmq', 'pubsub_port')))
        while True:
            try:
                publisher.send(self.inproc_pull.recv())
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.name)
                continue


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = time.time()
    payload['timestamp'] = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


def signal_handler(signum, frame):
    log.warn('Signal {} received.'.format(signum))
    log.setLevel(logging.DEBUG)


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.INFO)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)

    # set up signal handlers
    signal.signal(signal.SIGHUP, signal_handler)

    # i2c
    i2c_bus = ABEHelpers().get_smbus()

    # process configuration
    adcs = dict()
    for adc, address in config.items('adc_address'):
        log.info("Configuring '{}' @ '{}'".format(adc, address))
        address = address.split(',')
        adcs[adc] = ADCPi(i2c_bus,
                          int(address[0], 16),
                          int(address[1], 16),
                          12)

    ios = dict()
    for io, address in config.items('io_address'):
        log.info("Configuring '{}' @ '{}'".format(io, address))
        io_port = IoPi(i2c_bus,
                       int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    for relay, address in config.items('relay_address'):
        io, pin = tuple(address.split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.info("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    input_types = dict(config.items('input_type'))
    # name overrides location name
    input_names = dict(config.items('input_name'))
    input_locations = dict(config.items('input_location'))
    # construct the device representation
    input_devices = dict()
    output_types = dict(config.items('output_type'))
    output_locations = dict(config.items('output_location'))
    device_info = dict()
    device_info['inputs'] = list()
    for field, input_type in input_types.items():
        input_name = input_names[field]
        input_location = input_locations[field]
        device_description = {
            'name': input_name,
            'type': input_type,
            'location': input_location,
            'device_key': '{} {} ({})'.format(input_name, input_type, input_location)
        }
        device_info['inputs'].append(device_description)
        input_devices[field] = device_description
    device_info['outputs'] = list()
    for field, output_type in output_types.items():
        device_info['outputs'].append({
            'type': output_type,
            'location': output_locations[field],
            'device_key': '{} {}'.format(output_locations[field], output_type)
        })

    input_addresses = dict(config.items('input_address'))
    input_to_adc = dict()
    for field in input_addresses:
        adc, pin = tuple(input_addresses[field].split(':'))
        input_to_adc[field] = (adc, int(pin))
        # get the normal value
        log.info("ADC {} pin {} will detect '{}'".format(adc, pin, input_devices[field]['device_key']))

    relay_workers = list()
    relay_to_worker = dict()
    # start relays
    for relay_name in relay_to_io.keys():
        io, pin = relay_to_io[relay_name]
        relay = Relay(relay_name=relay_name, io=ios[io], pin=pin)
        relay.start()
        relay_workers.append(relay)
        relay_to_worker[relay_name] = relay.zmq_url

    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)

    relay_control = RelayControl(relay_mappings=relay_to_worker)
    relay_control.start()

    samples_processed = 0

    meter_history = dict()
    meters_last_posted = 0

    input_normal_values = dict(config.items('input_normal_values'))
    tamper_label = config.get('app', 'tamper_label')
    input_tamper_values = dict(config.items('input_tamper_values'))

    try:
        last_upload = 0
        device_history = dict()
        while True:
            active_devices = dict()
            output_samples = dict()
            for i in input_to_adc.keys():
                adc_name, pin = input_to_adc[i]
                sampled_value = adcs[adc_name].read_voltage(pin)
                normalized_value = (sampled_value / ADC_SAMPLE_MAX) * 100
                input_value = int(input_normal_values[i])
                device_key = input_devices[i]
                samples_processed += 1
                if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                    log.debug('Comparing {}.{}={} ({}v) '
                              'to {} ({}) (tolerance: {})'.format(adc_name,
                                                                  pin,
                                                                  normalized_value,
                                                                  sampled_value,
                                                                  input_value,
                                                                  device_key,
                                                                  SAMPLE_DEVIATION_TOLERANCE))
                if abs(normalized_value - input_value) <= SAMPLE_DEVIATION_TOLERANCE:
                    if 'meter' in device_key.lower() and device_key in meter_history:
                        meter_value, meter_state = meter_history[device_key]
                        meter_history[device_key] = (meter_value, False)
                    # nothing else to unset here, next input now
                    continue

                # a device has now gone out of normal range
                active_devices[device_key] = input_devices[field]

                if 'meter' in device_key.lower():
                    if device_key not in meter_history:
                        meter_history[device_key] = (1, True)
                    meter_value, meter_state = meter_history[device_key]
                    # latch
                    if not meter_state:
                        meter_history[device_key] = (meter_value+1, True)
                    if time.time() - meters_last_posted >= int(config.get('app', 'meter_sample_interval_seconds')):
                        meter_value, meter_state = meter_history[device_key]
                        log.debug('{} metered {}'.format(device_key, meter_value))
                        meters_last_posted = time.time()
                        meter_history[device_key] = (0, True)
                        active_devices[device_key]['sample_value'] = meter_value
                else:
                    output_detail = device_key
                    if i in input_tamper_values:
                        tamper_value = int(input_tamper_values[i])
                        if abs(normalized_value - tamper_value) <= SAMPLE_DEVIATION_TOLERANCE:
                            output_detail = '{} {}'.format(device_key, tamper_label)
                    if output_detail in device_history and time.time() - device_history[output_detail] < DEVICE_DEBOUNCE_SECONDS:
                        if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                            log.debug("Debouncing '{}' for another {} "
                                      "seconds.".format(output_detail,
                                                        int(DEVICE_DEBOUNCE_SECONDS - (time.time() - device_history[output_detail]))))
                        continue
                    else:
                        device_history[output_detail] = time.time()
                    output_samples[output_detail] = int(normalized_value)
                    active_devices[device_key]['sample_value'] = int(normalized_value)
            if len(active_devices) > 0:
                uploader_socket.send(make_payload(timestamp=time.time(),
                                                  data={
                                                      'samples': output_samples,
                                                      'active_devices': active_devices
                                                  }))
                last_upload = time.time()
            else:
                inactivity = time.time() - last_upload
                if inactivity > HEARTBEAT_INTERVAL_SECONDS:
                    uploader_socket.send(make_payload(data={
                        'statistics': {'sample_count': samples_processed},
                        'device_info': device_info
                    }))
                    last_upload = time.time()
            sleep(SAMPLE_INTERVAL_SECONDS)
    except(KeyboardInterrupt, SystemExit):
        log.info('Closing message queues...')
        uploader_socket.close()
        log.info('Terminating messaging context...')
        zmq_context.term()