#!/usr/bin/python
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import signal
import subprocess
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from threading import Thread
from time import sleep
from zmq import ContextTerminated

sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)

EXPECTED_FIELDS = 6
SAMPLE_DEVIATION_TOLERANCE = 4
UPLOAD_TIMEOUT_SECONDS = 1
HEARTBEAT_INTERVAL_SECONDS = 5
SAMPLE_INTERVAL_SECONDS = 1
SAMPLE_DEBOUNCE_COOLDOWN_SECONDS = 60
DEVICE_MONITOR_CONCURRENCY = 4
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

location = config.get('app', 'location')
zmq_context = zmq.Context()


def exec_cmd(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = p.communicate()
    return out, err, p.returncode


class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__()
        self.daemon = True
        # Socket to talk to accept samples
        self.samples = zmq_context.socket(zmq.PULL)
        self.samples.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://*:{port}'.format(port=config.get('zmq', 'port')))
        while True:
            try:
                publisher.send(self.samples.recv())
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = time.time()
    payload['timestamp'] = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
    payload['location'] = location
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)
    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)


    adc_address1 = 0x6A
    adc_address2 = 0x6B

    expander_address1 = 0x20
    expander_address2 = 0x21

    i2c_helper = ABEHelpers()
    newbus = i2c_helper.get_smbus()

    bus1 = IoPi(newbus, expander_address1)
    bus2 = IoPi(newbus, expander_address2)

    # We will write to the pins 9 to 16 from bus 1 so set port 1 to be outputs
    # turn off the pins
    bus1.set_port_direction(1, 0x00)
    bus1.write_port(1, 0x00)

    bus2.set_port_direction(1, 0x00)
    bus2.write_port(1, 0x00)

    try:
        while True:

            print 'About to write to pins now.'

            # 1s
            for i in range(1, 16):
                bus1.write_pin(i, 1)
                sleep(0.5)

            for i in range(1, 16):
                bus2.write_pin(i, 1)
                sleep(0.5)

            time.sleep(1)

            # 0s
            for i in range(1, 16):
                bus1.write_pin(i, 0)
                sleep(0.5)

            for i in range(1, 16):
                bus2.write_pin(i, 0)
                sleep(0.5)

            # don't flood the logs
            time.sleep(1)

    except(KeyboardInterrupt, SystemExit):
        log.info('Closing serial connection...')
        uploader_socket.close()
        log.info('Terminating messaging context...')
        zmq_context.term()