#!/usr/bin/python
import copy
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import serial
import signal
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_ADCPi import ADCPi
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from random import randint
from serial.serialutil import SerialException
from threading import Thread
from time import sleep
from zmq import ContextTerminated

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# PID file check
pidfile = '/var/run/{}.pid'.format(APP)
if os.path.isfile(pidfile):
    pid = int(open(pidfile, 'r').read())
    message = '{} already exists containing PID {}.'.format(pidfile, pid)
    proc_path = '/proc/{}/cmdline'.format(pid)
    # existing process?
    if os.path.isfile(proc_path):
        proc_info = open(proc_path, 'r').read()
        if 'python' in proc_info and APP in proc_info:
            print '{} is already running. {}'.format(APP, message)
            sys.exit(1)
    print '{} Removing stale PID file.'.format(message)
    # what's in the PID file is stale, destroy it
    os.unlink(pidfile)
# create a new PID file
file(pidfile, 'w').write(str(os.getpid()))

log = logging.getLogger(APP)
# no console by default
log.propagate = False

ADC_SAMPLE_MAX = 5.0
HEARTBEAT_INTERVAL_SECONDS = 5
RELAY_DEFAULT_ACTIVE_TIME_SECONDS = 1
SAMPLE_INTERVAL_SECONDS = 0.1
SAMPLE_DEVIATION_TOLERANCE = 5
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'
URL_WORKER_RELAY_CTRL = 'inproc://relay-ctrl'
URL_WORKER_RELAY = 'inproc://relay-{}'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)


class AlarmDecoder:

    #Baseline
    #0000000010100010001010101000001000000001010101010101010101010100
    #Ready
    #0000000010100010001010101000001000000001010101010101010101010000
    #AC/LB + Ready
    #0000000010100010001010101000001000000001010101010100010101010000
    #AC/LB + 1
    #0000000010100010001010101000001000000000010101010100010101010100
    #AC/LB + Arm + Stay
    #0000000010100010001010101000001000000001010101010100010000010100
    #AC/LB + 1
    #0000000010100010001010101000001000000000010101010100010101010100
    #AC/LB + 2
    #0000000010100010001010101000001000000001000101010100010101010100
    #2
    #0000000010100010001010101000001000000001000101010101010101010100
    #AC/LB + 3
    #0000000010100010001010101000001000000001010001010100010101010100
    #AC/LB + 4
    #0000000010100010001010101000001000000001010100010100010101010100
    #AC/LB + 5
    #0000000010100010001010101000001000000001010101000100010101010100
    #AC/LB + 6
    #0000000010100010001010101000001000000001010101010000010101010100

    BASELINE = 0xA22A8201555554
    ARM = 0x100
    STAY = 0x40
    #INSTANT = 0x??
    AC_LB = 0x1000
    READY = 0x4
    ZONE_1 = 0x1000000
    ZONE_2 = 0x400000
    ZONE_3 = 0x100000
    ZONE_4 = 0x40000
    ZONE_5 = 0x10000
    ZONE_6 = 0x4000

    def __init__(self):
        self._alarm_state = 0

    def set_state(self, state_string):
        log.debug('{} setting alarm state to [{}]'.format(self.__class__.__name__, state_string))
        if state_string is None or len(state_string) == 0 or ',' not in state_string:
            log.debug('Ignoring invalid alarm decoder word: [{}]'.format(state_string))
            return
        words = state_string.split(',')
        upper_word = long(words[0], base=16)
        lower_word = long(words[1], base=16)
        new_state = (upper_word << 31) | lower_word
        if new_state != self._alarm_state:
            self._alarm_state = new_state
            word_mapping = AlarmDecoder.BASELINE ^ self._alarm_state
            state_string = str(self)
            if len(state_string) > 0:
                log.info('Alarm state: {}'.format(state_string))
            elif word_mapping != 0:
                log.warn('Unmapped alarm state: {0:b}'.format(word_mapping).zfill(64))
            else:
                log.debug('Alarm state has changed to: {0:b}'.format(self._alarm_state).zfill(64))

    def __str__(self):
        zone_summary = list()
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_1 == AlarmDecoder.ZONE_1:
            zone_summary.append(config.get('house_alarm_decoder', 'Z1'))
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_2 == AlarmDecoder.ZONE_2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z2'))
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_3 == AlarmDecoder.ZONE_3:
            zone_summary.append(config.get('house_alarm_decoder', 'Z3'))
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_4 == AlarmDecoder.ZONE_4:
            zone_summary.append(config.get('house_alarm_decoder', 'Z4'))
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_5 == AlarmDecoder.ZONE_5:
            zone_summary.append(config.get('house_alarm_decoder', 'Z5'))
        if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_6 == AlarmDecoder.ZONE_6:
            zone_summary.append(config.get('house_alarm_decoder', 'Z6'))
        return str(zone_summary)

class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        # inproc socket to accept messages to publish
        # to the outside world
        self.inproc_pull = zmq_context.socket(zmq.PULL)
        self.inproc_pull.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                  port=config.get('zmq', 'pubsub_port')))
        while True:
            try:
                publisher.send(Uploader.make_payload(
                    timestamp=None,
                    data=self.inproc_pull.recv_pyobj()))
            except ContextTerminated:
                self.inproc_pull.close()
                publisher.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue

    @staticmethod
    def make_payload(timestamp=None, data=None):
        payload = dict()
        if timestamp is None:
            timestamp = datetime.utcnow().replace(tzinfo=pytz.utc)
        elif isinstance(timestamp, float):
            timestamp = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc)
        if isinstance(timestamp, datetime):
            timestamp = timestamp.strftime(DATE_FORMAT)
        if not isinstance(timestamp, basestring):
            log.warn('Non-string timestamp {} for payload {}'.format(timestamp, data))
        payload['timestamp'] = timestamp
        if data is not None and len(data) > 0:
            payload['data'] = data
        log.debug(json.dumps(payload))
        return umsgpack.packb(payload)


class DeviceActivator(Thread):

    def __init__(self):
        super(DeviceActivator, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.listener = zmq_context.socket(zmq.PULL)
        # what to do with device activations
        self.relay_control = zmq_context.socket(zmq.PUSH)

    def run(self):
        # outputs
        self.relay_control.connect(URL_WORKER_RELAY_CTRL)
        # Socket to talk to the outside world
        self.listener.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                      port=config.get('zmq', 'pushpull_port')))
        while True:
            try:
                event = umsgpack.unpackb(self.listener.recv())
                log.debug(event)
                if 'data' not in event:
                    log.warn('Unknown event data: {}'.format(event))
                    continue
                event_data = event['data']
                if 'trigger_output' in event_data:
                    output_type = event_data['trigger_output']['type']
                    if 'input_context' not in event_data:
                        log.warn('{} requested without context, ignoring.'.format(output_type))
                        continue
                    delay = None
                    if 'trigger_duration' in event_data:
                        delay = event_data['trigger_duration']
                    # send all output activations to the relay control, which will filter accordingly
                    self.relay_control.send_pyobj((event_data['trigger_output']['device_key'], delay))
            except ContextTerminated:
                self.listener.close()
                self.relay_control.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class Relay(Thread):

    def __init__(self, relay_name, io, pin):
        super(Relay, self).__init__()
        self.daemon = True
        self._name = relay_name
        self._io = io
        self._pin = pin
        self._zmq_url = URL_WORKER_RELAY.format(relay_name)
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(self._zmq_url)

    @property
    def zmq_url(self):
        return self._zmq_url

    def run(self):
        while True:
            try:
                relay_ctrl = self.socket.recv_pyobj()
                if 'state' in relay_ctrl:
                    if relay_ctrl['state'] is True:
                        self._io.write_pin(self._pin, 1)
                        # sleep
                        if 'delay' in relay_ctrl:
                            delay = relay_ctrl['delay']
                        else:
                            delay = RELAY_DEFAULT_ACTIVE_TIME_SECONDS
                        log.info("Activating {} for {} seconds.".format(self._name, delay))
                        self._io.write_pin(self._pin, 1)
                        sleep(float(delay))
                    self._io.write_pin(self._pin, 0)
            except ContextTerminated:
                self.socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class RelayControl(Thread):

    def __init__(self, relay_mappings):
        super(RelayControl, self).__init__()
        self.daemon = True
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_RELAY_CTRL)
        # Push socket to control relays
        self._sockets = dict()
        for relay, worker_url in relay_mappings.items():
            socket = zmq_context.socket(zmq.PUSH)
            self._sockets[relay] = socket
            socket.connect(worker_url)
        self._output_to_relay = dict()

    def run(self):
        while True:
            try:
                device_key, delay = self.socket.recv_pyobj()
                log.debug("Relay event for '{}'".format(device_key))
                if device_key not in self._output_to_relay:
                    log.debug("'{}' is not configured for relay control".format(device_key))
                    continue
                relay = self._output_to_relay[device_key]
                if relay in self._sockets:
                    log.info("'{}' => '{}'".format(device_key, relay))
                    relay_cmd = {
                        'state': True
                    }
                    if delay:
                        relay_cmd['delay'] = delay
                    self._sockets[relay].send_pyobj(relay_cmd)
                else:
                    log.error("'{}' refers to non-existent relay '{}'".format(device_key, relay))
            except ContextTerminated:
                self.socket.close()
                for socket in self._sockets.values():
                    socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue

    def add_output(self, device_key, relay):
        if device_key in self._output_to_relay:
            raise RuntimeError('{} is already associated with {}. Cannot also associate {}.'.format(
                device_key,
                self._output_to_relay[device_key],
                relay))
        self._output_to_relay[device_key] = relay


class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.INFO)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)

    # serial
    com1 = serial.Serial(
        port=config.get('serial', 'port'),
        baudrate=config.getint('serial', 'baudrate'),
        timeout=1)
    alarm_decoder = AlarmDecoder()

    # i2c
    i2c_bus = ABEHelpers().get_smbus()

    # process configuration
    adcs = dict()
    for adc, address in config.items('adc_address'):
        log.info("Configuring '{}' @ '{}'".format(adc, address))
        address = address.split(',')
        adcs[adc] = ADCPi(i2c_bus,
                          int(address[0], 16),
                          int(address[1], 16),
                          12)

    ios = dict()
    for io, address in config.items('io_address'):
        log.info("Configuring '{}' @ '{}'".format(io, address))
        io_port = IoPi(i2c_bus,
                       int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    for relay, address in config.items('relay_address'):
        io, pin = tuple(address.split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.info("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    relay_workers = list()
    relay_to_worker = dict()
    # start relays
    for relay_name in relay_to_io.keys():
        io, pin = relay_to_io[relay_name]
        relay = Relay(relay_name=relay_name, io=ios[io], pin=pin)
        relay.start()
        relay_workers.append(relay)
        relay_to_worker[relay_name] = relay.zmq_url

    relay_control = RelayControl(relay_mappings=relay_to_worker)

    input_types = dict(config.items('input_type'))
    # name overrides location name
    input_names = dict(config.items('input_name'))
    input_locations = dict(config.items('input_location'))
    # construct the device representation
    input_devices = dict()
    output_types = dict(config.items('output_type'))
    output_locations = dict(config.items('output_location'))
    device_info = dict()
    device_info['inputs'] = list()
    for field, input_type in input_types.items():
        input_name = input_names[field]
        input_location = input_locations[field]
        device_description = {
            'name': input_name,
            'type': input_type,
            'location': input_location,
            'device_key': '{} {} ({})'.format(input_name, input_type, input_location),
            'device_label': '{} {}'.format(input_name, input_type)
        }
        device_info['inputs'].append(device_description)
        input_devices[field] = device_description
    device_info['outputs'] = list()
    for field, output_type in output_types.items():
        output_location = output_locations[field]
        device_key = '{} {}'.format(output_location, output_type)
        device_info['outputs'].append({
            'type': output_type,
            'location': output_location,
            'device_key': device_key
        })
        if config.has_option('output_relay', field):
            relay = config.get('output_relay', field)
            log.info("'{}' will trigger '{}'".format(device_key, relay))
            relay_control.add_output(
                device_key=device_key,
                relay=relay)

    input_addresses = dict(config.items('input_address'))
    input_to_adc = dict()
    for field in input_addresses:
        adc, pin = tuple(input_addresses[field].split(':'))
        input_to_adc[field] = (adc, int(pin))
        # get the normal value
        log.info("ADC {} pin {} will detect '{}'".format(adc, pin, input_devices[field]['device_key']))

    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)

    # start relay control
    relay_control.start()

    device_activator = DeviceActivator()
    device_activator.start()

    samples_processed = 0

    meter_history = dict()
    meters_last_posted = 0

    input_normal_values = dict(config.items('input_normal_values'))
    tamper_label = config.get('app', 'tamper_label')
    input_tamper_values = dict(config.items('input_tamper_values'))

    # set up signal handlers
    signal_handler = SignalHandler()

    try:
        last_upload = 0
        device_history = dict()
        while True:
            # serial data for the alarm device type
            try:
                alarm_state_data = com1.readline()
                while len(alarm_state_data) > 0:
                    alarm_decoder.set_state(alarm_state_data)
                    alarm_state_data = com1.readline()
            except SerialException:
                if com1.closed:
                    log.error('{} is closed, cannot read serial data.'.format(config.get('serial', 'port')))
            active_devices = list()
            output_samples = dict()
            for i in input_to_adc.keys():
                adc_name, pin = input_to_adc[i]
                sampled_value = adcs[adc_name].read_voltage(pin)
                normalized_value = (sampled_value / ADC_SAMPLE_MAX) * 100
                input_value = int(input_normal_values[i])
                device_key = input_devices[i]['device_key']
                device_type = input_devices[i]['type']
                samples_processed += 1
                if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                    log.debug('Comparing {}.{}={} ({}v) '
                              'to {} ({}) (tolerance: {})'.format(adc_name,
                                                                  pin,
                                                                  normalized_value,
                                                                  sampled_value,
                                                                  input_value,
                                                                  device_key,
                                                                  SAMPLE_DEVIATION_TOLERANCE))
                if abs(normalized_value - input_value) <= SAMPLE_DEVIATION_TOLERANCE:
                    if 'meter' in device_key.lower() and device_key in meter_history:
                        meter_value, meter_state = meter_history[device_key]
                        meter_history[device_key] = (meter_value, False)
                    # forget that this device was active
                    if device_key in device_history:
                        log.debug("'{}' is no longer active.".format(device_key))
                        del device_history[device_key]
                    # nothing else to unset here, next input now
                    continue

                # a device has now gone out of normal range

                if 'meter' in device_key.lower():
                    if device_key not in meter_history:
                        meter_history[device_key] = (1, True)
                    meter_value, meter_state = meter_history[device_key]
                    # latch
                    if not meter_state:
                        meter_history[device_key] = (meter_value+1, True)
                    if time.time() - meters_last_posted >= int(config.get('app', 'meter_sample_interval_seconds')):
                        meter_value, meter_state = meter_history[device_key]
                        log.debug('{} metered {}'.format(device_key, meter_value))
                        meters_last_posted = time.time()
                        meter_history[device_key] = (0, True)
                        input_device = copy.copy(input_devices[i])
                        input_device['sample_value'] = meter_value
                        active_devices.append(input_device)
                    else:
                        continue
                else:
                    device_event_distinction = device_key
                    output_samples[device_key] = int(normalized_value)
                    input_device = copy.copy(input_devices[i])
                    input_device['sample_value'] = int(normalized_value)
                    event_detail = None
                    if i in input_tamper_values:
                        tamper_value = int(input_tamper_values[i])
                        if abs(normalized_value - tamper_value) <= SAMPLE_DEVIATION_TOLERANCE:
                            event_detail = tamper_label
                            device_event_distinction = '{} {}'.format(device_key, tamper_label)
                    # decorate the alarm input type if it is not in a fault state
                    if device_type.lower() == 'alarm' and 'event_detail' not in input_device:
                        # get the latest state data
                        try:
                            alarm_state_data = com1.readline()
                            while len(alarm_state_data) > 0:
                                alarm_decoder.set_state(alarm_state_data)
                                alarm_state_data = com1.readline()
                            event_detail = str(alarm_decoder)
                        except SerialException:
                            if com1.closed:
                                log.error('{} is closed, cannot read serial data.'.format(config.get('serial', 'port')))
                    # now include the event detail
                    if event_detail:
                        input_device['event_detail'] = event_detail
                    # determine whether the value has changed
                    if device_key in device_history:
                        historic_value, sampled_at, historic_detail = device_history[device_key]
                        # has the value stayed the same?
                        if abs(normalized_value - historic_value) <= SAMPLE_DEVIATION_TOLERANCE and event_detail == historic_detail:
                            # sample to avoid log spam
                            if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                                log.debug("Debouncing '{}' activated {} seconds "
                                          "ago.".format(device_event_distinction,
                                                        int(time.time() - sampled_at)))
                            continue
                    # update the device history and treat as active
                    device_history[device_key] = (normalized_value, time.time(), event_detail)
                    # add the input device to the 'active' list
                    active_devices.append(input_device)
            if len(active_devices) > 0:
                uploader_socket.send_pyobj({
                    'samples': output_samples,
                    'active_devices': active_devices
                })
                last_upload = time.time()
            else:
                inactivity = time.time() - last_upload
                if inactivity > HEARTBEAT_INTERVAL_SECONDS:
                    uploader_socket.send_pyobj({
                        'statistics': {'sample_count': samples_processed},
                        'device_info': device_info
                    })
                    last_upload = time.time()
            sleep(SAMPLE_INTERVAL_SECONDS)
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated):
        com1.close()
        uploader_socket.close()
        zmq_context.term()
    finally:
        log.info('Removing PID file {}'.format(pidfile))
        os.unlink(pidfile)

    log.info('Exiting with code {}'.format(signal_handler.last_signal))
    # exit using the signal, if any
    sys.exit(signal_handler.last_signal)
