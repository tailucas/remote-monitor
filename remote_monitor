#!/usr/bin/python
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import signal
import subprocess
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_ADCPi import ADCPi
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from threading import Thread
from time import sleep
from zmq import ContextTerminated

sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)

EXPECTED_FIELDS = 6
SAMPLE_DEVIATION_TOLERANCE = 4
UPLOAD_TIMEOUT_SECONDS = 1
HEARTBEAT_INTERVAL_SECONDS = 5
SAMPLE_INTERVAL_SECONDS = 1
SAMPLE_DEBOUNCE_COOLDOWN_SECONDS = 60
DEVICE_MONITOR_CONCURRENCY = 4
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

location = config.get('app', 'location')
zmq_context = zmq.Context()


def exec_cmd(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = p.communicate()
    return out, err, p.returncode


class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__()
        self.daemon = True
        # Socket to talk to accept samples
        self.samples = zmq_context.socket(zmq.PULL)
        self.samples.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://*:{port}'.format(port=config.get('zmq', 'port')))
        while True:
            try:
                publisher.send(self.samples.recv())
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = time.time()
    payload['timestamp'] = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
    payload['location'] = location
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)
    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)


    adc1_address1 = 0x68
    adc1_address2 = 0x69
    adc2_address1 = 0x6A
    adc2_address2 = 0x6B

    expander_address1 = 0x20
    expander_address2 = 0x21

    i2c_helper = ABEHelpers()
    i2cbus = i2c_helper.get_smbus()

    adc1 = ADCPi(i2cbus, adc1_address1, adc1_address2, 12)
    adc2 = ADCPi(i2cbus, adc2_address1, adc2_address2, 12)

    io_port1 = IoPi(i2cbus, expander_address1)
    io_port1.set_port_direction(0, 0x00)
    io_port1.set_port_direction(1, 0x00)
    io_port1.write_port(0, 0x00)
    io_port1.write_port(1, 0x00)

    try:

        # 1s
        io_port1.write_pin(14, 1)
        sleep(1)
        io_port1.write_pin(3, 1)
        sleep(1)
        io_port1.write_pin(4, 1)
        sleep(1)
        io_port1.write_pin(13, 1)
        sleep(1)
        io_port1.write_port(0, 0x00)
        io_port1.write_port(1, 0x00)
        sleep(1)

        while True:
            for i in range(1, 9):
                log.info('ADC1, pin {}: {}'.format(i, adc1.read_raw(i)))
            for i in range(1, 9):
                log.info('ADC2, pin {}: {}'.format(i, adc2.read_raw(i)))
            sleep(60)

    except(KeyboardInterrupt, SystemExit):
        log.info('Closing serial connection...')
        uploader_socket.close()
        log.info('Terminating messaging context...')
        zmq_context.term()