#!/usr/bin/python
import copy
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import serial
import signal
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_ADCPi import ADCPi
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from random import randint
from serial.serialutil import SerialException
from threading import Thread
from time import sleep
from zmq import ContextTerminated

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# PID file check
pidfile = '/var/run/{}.pid'.format(APP)
if os.path.isfile(pidfile):
    try:
        pid = int(open(pidfile, 'r').read())
        message = '{} already exists containing PID {}.'.format(pidfile, pid)
        proc_path = '/proc/{}/cmdline'.format(pid)
        # existing process?
        if os.path.isfile(proc_path):
            proc_info = open(proc_path, 'r').read()
            if 'python' in proc_info and APP in proc_info:
                print '{} is already running. {}'.format(APP, message)
                sys.exit(1)
    except ValueError:
        message = '{} contains no valid PID.'.format(pidfile)
    print '{} Removing stale PID file.'.format(message)
    # what's in the PID file is stale, destroy it
    os.unlink(pidfile)
# create a new PID file
file(pidfile, 'w').write(str(os.getpid()))

log = logging.getLogger(APP)
# no console by default
log.propagate = False

ADC_SAMPLE_MAX = 5.0
HEARTBEAT_INTERVAL_SECONDS = 5
RELAY_DEFAULT_ACTIVE_TIME_SECONDS = 1
SAMPLE_INTERVAL_SECONDS = 0.1
SAMPLE_DEVIATION_TOLERANCE = 5
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'
URL_WORKER_RELAY_CTRL = 'inproc://relay-ctrl'
URL_WORKER_RELAY = 'inproc://relay-{}'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)


class AlarmDecoder(Thread):

    # Baseline:           0000000010100010001010101000001000000001010101010101010101010100
    # Ready:              0000000010100010001010101000001000000001010101010101010101010000
    # AC/LB + Ready:      0000000010100010001010101000001000000001010101010100010101010000
    # AC/LB + 1:          0000000010100010001010101000001000000000010101010100010101010100
    # AC/LB + Arm + Stay: 0000000010100010001010101000001000000001010101010100010000010100
    # AC/LB + 1:          0000000010100010001010101000001000000000010101010100010101010100
    # AC/LB + 2:          0000000010100010001010101000001000000001000101010100010101010100
    # 2:                  0000000010100010001010101000001000000001000101010101010101010100
    # AC/LB + 3:          0000000010100010001010101000001000000001010001010100010101010100
    # AC/LB + 4:          0000000010100010001010101000001000000001010100010100010101010100
    # AC/LB + 5:          0000000010100010001010101000001000000001010101000100010101010100
    # AC/LB + 6:          0000000010100010001010101000001000000001010101010000010101010100

    # 1111111111111111111111111111111111111110000000000000000000000000
    INPUT_MASK = 0xFFFFFFFFFE000000
    # 0000000000000000000000000000000000000001111111111111111111111111
    STATUS_MASK = 0x1FFFFFF
    # 0000000010100010001010101000001000000001010101010101010101010100
    BASELINE = 0xA22A8201555554
    # 0000000000000000000000000000000000000010101010101010101010101010
    STATUS_VALIDITY_MASK = 0x2AAAAAA
    # 1010101010101010101010101010101000000000000000000000000000000000
    INPUT_VALIDITY_MASK = 0xAAAAAAAA00000000
    # 0000000000000000000000000100000000000000000000101010000000000000
    USER_INPUT_1 = 0x4000000000
    # 0000000000000000000000000001000000000000000000000000100000000010
    USER_INPUT_2 = 0x1000000000
    # 0000000000000001000000000000000000000000000000000000000000000000
    USER_INPUT_3 = 0x1000000000000
    # 0000000000000000000001000000000000000000000000000000000010000000
    USER_INPUT_4 = 0x40000000000
    # 0000000000000000010000000000000000000000000000000000000000000000
    USER_INPUT_5 = 0x400000000000
    # 0000000000000000000000000000000100000000000000000000000000000000
    USER_INPUT_6 = 0x100000000
    # 0000000000000000000000010000000000000000000010000000000000000000
    USER_INPUT_7 = 0x10000000000
    # 0000000000000100000000000000000000000000000000000000000000000000
    USER_INPUT_8 = 0x4000000000000
    # 0000000000000000000100000000000000000000000000000000000000000000
    USER_INPUT_9 = 0x100000000000
    # 0000000000000000000000000000000010000000000000000000000000000000
    USER_INPUT_0 = 0x80000000
    # 0000000000010000000000000000000000000000001000000000000000000000
    USER_INPUT_AST = 0x10000000000000
    # 0000000001000000000000000000000000000000100000000000000000000000
    USER_INPUT_HASH = 0x40000000000000
    # 0000000000000000000000000000010000000000000000000000000000000000
    USER_INPUT_STAY = 0x400000000
    # 0000000000000000000000000000000000100000000000000000000000000000
    USER_INPUT_INSTANT = 0x20000000
    # 0100000000000000000000000000000000000000000000000000000000000000
    USER_INPUT_BYPASS = 0x4000000000000000
    # 0001010100000000000000000000000000000010000000000000000000000000
    USER_INPUT_CODE = 0x1500000000000000
    # 0000000000000000000100000000000000000000000000000000000000000000
    USER_INPUT_FIRE1 = 0x100000000000
    # 0000000000000000000000010000000000000000000010000000000000100000
    USER_INPUT_FIRE2 = 0x10000000000
    # 0000000000000001000000000000000000000000000000000000001000000000
    USER_INPUT_MED1 = 0x1000000000000
    # 0000000000000000000000000100000000000000000000101010000000001000
    USER_INPUT_MED2 = 0x4000000000
    # 0000000001000000000000000000000000000000100000000000000000000000
    USER_INPUT_POL1 = 0x40000000000000
    # 0000000000010000000000000000000000000000001000000000000000000000
    USER_INPUT_POL2 = 0x10000000000000

    # 0000000000000000000000000000000000000001000000000000000000000000
    ZONE_1 = 0x1000000
    # 0000000000000000000000000000000000000000010000000000000000000000
    ZONE_2 = 0x400000
    # 0000000000000000000000000000000000000000000100000000000000000000
    ZONE_3 = 0x100000
    # 0000000000000000000000000000000000000000000001000000000000000000
    ZONE_4 = 0x40000
    # 0000000000000000000000000000000000000000000000010000000000000000
    ZONE_5 = 0x10000
    # 0000000000000000000000000000000000000000000000000100000000000000
    ZONE_6 = 0x4000
    # 0000000000000000000000000000000000000000000000000001000000000000
    AC_LB = 0x1000
    # 0000000000000000000000000000000000000000000000000000010000000000
    #INSTANT = 0x400??
    # 0000000000000000000000000000000000000000000000000000000100000000
    ARM = 0x100
    # 0000000000000000000000000000000000000000000000000000000001000000
    STAY = 0x40
    # 0000000000000000000000000000000000000000000000000000000000010000
    #INSTANT = 0x10??
    # 0000000000000000000000000000000000000000000000000000000000000100
    READY = 0x4
    # 0000000000000000000000000000000000000000000000000000000000000001
    BUZZER = 0x1

    def __init__(self):
        super(AlarmDecoder, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        self._alarm_state = 0
        # serial
        self._com1 = serial.Serial(
            port=config.get('serial', 'port'),
            baudrate=config.getint('serial', 'baudrate'),
            timeout=1)
        # state init
        self._zone_states = dict()
        self._zone_states[AlarmDecoder.ARM] = \
        self._zone_states[AlarmDecoder.STAY] = \
        self._zone_states[AlarmDecoder.AC_LB] = \
        self._zone_states[AlarmDecoder.READY] = \
        self._zone_states[AlarmDecoder.ZONE_1] = \
        self._zone_states[AlarmDecoder.ZONE_2] = \
        self._zone_states[AlarmDecoder.ZONE_3] = \
        self._zone_states[AlarmDecoder.ZONE_4] = \
        self._zone_states[AlarmDecoder.ZONE_5] = \
        self._zone_states[AlarmDecoder.ZONE_6] = 0

    def run(self):
        while True:
            # serial data for the alarm device type
            try:
                alarm_state_data = self._com1.readline()
                while len(alarm_state_data) > 0:
                    self.set_state(alarm_state_data)
                    alarm_state_data = self._com1.readline()
            except SerialException:
                if self._com1.closed:
                    log.error('{} is closed, cannot read serial data.'.format(config.get('serial', 'port')))
                    break
            sleep(SAMPLE_INTERVAL_SECONDS)

    def stop(self):
        if not self._com1.closed:
            self._com1.close()

    def set_state(self, state_string):
        log.debug('{} setting alarm state to [{}]'.format(self.__class__.__name__, state_string))
        if state_string is None:
            return
        # trim
        state_string = state_string.rstrip()
        if len(state_string) == 0 or ',' not in state_string:
            log.debug('Ignoring invalid alarm decoder word: [{}]'.format(state_string))
            return
        words = state_string.split(',')
        upper_word = long(words[0], base=16)
        lower_word = long(words[1], base=16)
        new_state = (upper_word << 31) | lower_word
        # word containing valid state change
        if ((AlarmDecoder.BASELINE ^ new_state) & AlarmDecoder.STATUS_VALIDITY_MASK == 0) and (new_state != self._alarm_state):
            self._alarm_state = new_state
            # set the individual zone states
            now = time.time()
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ARM == AlarmDecoder.ARM:
                self._zone_states[AlarmDecoder.ARM] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.STAY == AlarmDecoder.STAY:
                self._zone_states[AlarmDecoder.STAY] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.AC_LB == AlarmDecoder.AC_LB:
                self._zone_states[AlarmDecoder.AC_LB] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.READY == AlarmDecoder.READY:
                self._zone_states[AlarmDecoder.READY] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_1 == AlarmDecoder.ZONE_1:
                self._zone_states[AlarmDecoder.ZONE_1] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_2 == AlarmDecoder.ZONE_2:
                self._zone_states[AlarmDecoder.ZONE_2] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_3 == AlarmDecoder.ZONE_3:
                self._zone_states[AlarmDecoder.ZONE_3] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_4 == AlarmDecoder.ZONE_4:
                self._zone_states[AlarmDecoder.ZONE_4] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_5 == AlarmDecoder.ZONE_5:
                self._zone_states[AlarmDecoder.ZONE_5] = now
            if (AlarmDecoder.BASELINE ^ self._alarm_state) & AlarmDecoder.ZONE_6 == AlarmDecoder.ZONE_6:
                self._zone_states[AlarmDecoder.ZONE_6] = now
            # debugging
            bin_string = '{0:b}'.format(AlarmDecoder.BASELINE ^ self._alarm_state).zfill(64)
            log.debug('Alarm state has changed to: {}'.format(bin_string))
            to_string = str(self)
            if len(to_string) > 0:
                log.debug('Alarm state description: {}'.format(to_string))
        elif ((AlarmDecoder.BASELINE ^ new_state) & AlarmDecoder.INPUT_VALIDITY_MASK == 0):
            if (AlarmDecoder.BASELINE ^ new_state) & AlarmDecoder.USER_INPUT_1 == AlarmDecoder.USER_INPUT_1:
                log.info('User input 1')
            if (AlarmDecoder.BASELINE ^ new_state) & AlarmDecoder.USER_INPUT_2 == AlarmDecoder.USER_INPUT_2:
                log.info('User input 2')
        else:
            bin_string = '{0:b}'.format(new_state).zfill(64)
            log.warn('Ignoring invalid alarm status word: {} derived from {}'.format(bin_string, state_string))
            return

    def __str__(self):
        zone_summary = list()
        now = time.time()
        if now - self._zone_states[AlarmDecoder.ZONE_1] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z1'))
        if now - self._zone_states[AlarmDecoder.ZONE_2] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z2'))
        if now - self._zone_states[AlarmDecoder.ZONE_3] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z3'))
        if now - self._zone_states[AlarmDecoder.ZONE_4] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z4'))
        if now - self._zone_states[AlarmDecoder.ZONE_5] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z5'))
        if now - self._zone_states[AlarmDecoder.ZONE_6] <= 2:
            zone_summary.append(config.get('house_alarm_decoder', 'Z6'))
        return ', '.join(zone_summary)

class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        # inproc socket to accept messages to publish
        # to the outside world
        self.inproc_pull = zmq_context.socket(zmq.PULL)
        self.inproc_pull.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                  port=config.get('zmq', 'pubsub_port')))
        while True:
            try:
                publisher.send(Uploader.make_payload(
                    timestamp=None,
                    data=self.inproc_pull.recv_pyobj()))
            except ContextTerminated:
                self.inproc_pull.close()
                publisher.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue

    @staticmethod
    def make_payload(timestamp=None, data=None):
        payload = dict()
        if timestamp is None:
            timestamp = datetime.utcnow().replace(tzinfo=pytz.utc)
        elif isinstance(timestamp, float):
            timestamp = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc)
        if isinstance(timestamp, datetime):
            timestamp = timestamp.strftime(DATE_FORMAT)
        if not isinstance(timestamp, basestring):
            log.warn('Non-string timestamp {} for payload {}'.format(timestamp, data))
        payload['timestamp'] = timestamp
        if data is not None and len(data) > 0:
            payload['data'] = data
        log.debug(json.dumps(payload))
        return umsgpack.packb(payload)


class DeviceActivator(Thread):

    def __init__(self):
        super(DeviceActivator, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.listener = zmq_context.socket(zmq.PULL)
        # what to do with device activations
        self.relay_control = zmq_context.socket(zmq.PUSH)

    def run(self):
        # outputs
        self.relay_control.connect(URL_WORKER_RELAY_CTRL)
        # Socket to talk to the outside world
        self.listener.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                      port=config.get('zmq', 'pushpull_port')))
        while True:
            try:
                event = umsgpack.unpackb(self.listener.recv())
                log.debug(event)
                if 'data' not in event:
                    log.warn('Unknown event data: {}'.format(event))
                    continue
                event_data = event['data']
                if 'trigger_output' in event_data:
                    output_type = event_data['trigger_output']['type']
                    if 'input_context' not in event_data:
                        log.warn('{} requested without context, ignoring.'.format(output_type))
                        continue
                    delay = None
                    if 'trigger_duration' in event_data:
                        delay = event_data['trigger_duration']
                    # send all output activations to the relay control, which will filter accordingly
                    self.relay_control.send_pyobj((event_data['trigger_output']['device_key'], delay))
            except ContextTerminated:
                self.listener.close()
                self.relay_control.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class Relay(Thread):

    def __init__(self, relay_name, io, pin):
        super(Relay, self).__init__()
        self.daemon = True
        self._name = relay_name
        self._io = io
        self._pin = pin
        self._zmq_url = URL_WORKER_RELAY.format(relay_name)
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(self._zmq_url)

    @property
    def zmq_url(self):
        return self._zmq_url

    def run(self):
        while True:
            try:
                relay_ctrl = self.socket.recv_pyobj()
                if 'state' in relay_ctrl:
                    if relay_ctrl['state'] is True:
                        self._io.write_pin(self._pin, 1)
                        # sleep
                        if 'delay' in relay_ctrl:
                            delay = relay_ctrl['delay']
                        else:
                            delay = RELAY_DEFAULT_ACTIVE_TIME_SECONDS
                        log.info("Activating {} for {} seconds.".format(self._name, delay))
                        self._io.write_pin(self._pin, 1)
                        sleep(float(delay))
                    self._io.write_pin(self._pin, 0)
            except ContextTerminated:
                self.socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class RelayControl(Thread):

    def __init__(self, relay_mappings):
        super(RelayControl, self).__init__()
        self.daemon = True
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_RELAY_CTRL)
        # Push socket to control relays
        self._sockets = dict()
        for relay, worker_url in relay_mappings.items():
            socket = zmq_context.socket(zmq.PUSH)
            self._sockets[relay] = socket
            socket.connect(worker_url)
        self._output_to_relay = dict()

    def run(self):
        while True:
            try:
                device_key, delay = self.socket.recv_pyobj()
                log.debug("Relay event for '{}'".format(device_key))
                if device_key not in self._output_to_relay:
                    log.debug("'{}' is not configured for relay control".format(device_key))
                    continue
                relay = self._output_to_relay[device_key]
                if relay in self._sockets:
                    log.info("'{}' => '{}'".format(device_key, relay))
                    relay_cmd = {
                        'state': True
                    }
                    if delay:
                        relay_cmd['delay'] = delay
                    self._sockets[relay].send_pyobj(relay_cmd)
                else:
                    log.error("'{}' refers to non-existent relay '{}'".format(device_key, relay))
            except ContextTerminated:
                self.socket.close()
                for socket in self._sockets.values():
                    socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue

    def add_output(self, device_key, relay):
        if device_key in self._output_to_relay:
            raise RuntimeError('{} is already associated with {}. Cannot also associate {}.'.format(
                device_key,
                self._output_to_relay[device_key],
                relay))
        self._output_to_relay[device_key] = relay


class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.INFO)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)

    # i2c
    i2c_bus = ABEHelpers().get_smbus()

    # process configuration
    adcs = dict()
    for adc, address in config.items('adc_address'):
        log.info("Configuring '{}' @ '{}'".format(adc, address))
        address = address.split(',')
        adcs[adc] = ADCPi(i2c_bus,
                          int(address[0], 16),
                          int(address[1], 16),
                          12)

    ios = dict()
    for io, address in config.items('io_address'):
        log.info("Configuring '{}' @ '{}'".format(io, address))
        io_port = IoPi(i2c_bus,
                       int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    for relay, address in config.items('relay_address'):
        io, pin = tuple(address.split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.info("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    relay_workers = list()
    relay_to_worker = dict()
    # start relays
    for relay_name in relay_to_io.keys():
        io, pin = relay_to_io[relay_name]
        relay = Relay(relay_name=relay_name, io=ios[io], pin=pin)
        relay.start()
        relay_workers.append(relay)
        relay_to_worker[relay_name] = relay.zmq_url

    relay_control = RelayControl(relay_mappings=relay_to_worker)

    input_types = dict(config.items('input_type'))
    # name overrides location name
    input_names = dict(config.items('input_name'))
    input_locations = dict(config.items('input_location'))
    # construct the device representation
    input_devices = dict()
    output_types = dict(config.items('output_type'))
    output_locations = dict(config.items('output_location'))
    device_info = dict()
    device_info['inputs'] = list()
    for field, input_type in input_types.items():
        input_name = input_names[field]
        input_location = input_locations[field]
        device_description = {
            'name': input_name,
            'type': input_type,
            'location': input_location,
            'device_key': '{} {} ({})'.format(input_name, input_type, input_location),
            'device_label': '{} {}'.format(input_name, input_type)
        }
        device_info['inputs'].append(device_description)
        input_devices[field] = device_description
    device_info['outputs'] = list()
    for field, output_type in output_types.items():
        output_location = output_locations[field]
        device_key = '{} {}'.format(output_location, output_type)
        device_info['outputs'].append({
            'type': output_type,
            'location': output_location,
            'device_key': device_key
        })
        if config.has_option('output_relay', field):
            relay = config.get('output_relay', field)
            log.info("'{}' will trigger '{}'".format(device_key, relay))
            relay_control.add_output(
                device_key=device_key,
                relay=relay)

    input_addresses = dict(config.items('input_address'))
    input_to_adc = dict()
    for field in input_addresses:
        adc, pin = tuple(input_addresses[field].split(':'))
        input_to_adc[field] = (adc, int(pin))
        # get the normal value
        log.info("ADC {} pin {} will detect '{}'".format(adc, pin, input_devices[field]['device_key']))

    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)

    # start relay control
    relay_control.start()

    device_activator = DeviceActivator()
    device_activator.start()

    # alarm decoder
    alarm_decoder = AlarmDecoder()
    alarm_decoder.start()

    samples_processed = 0

    meter_history = dict()
    meters_last_posted = 0

    input_normal_values = dict(config.items('input_normal_values'))
    tamper_label = config.get('app', 'tamper_label')
    input_tamper_values = dict(config.items('input_tamper_values'))

    # set up signal handlers
    signal_handler = SignalHandler()

    try:
        last_upload = 0
        device_history = dict()
        while True:

            active_devices = list()
            output_samples = dict()
            for i in input_to_adc.keys():
                adc_name, pin = input_to_adc[i]
                sampled_value = adcs[adc_name].read_voltage(pin)
                normalized_value = (sampled_value / ADC_SAMPLE_MAX) * 100
                input_value = int(input_normal_values[i])
                device_key = input_devices[i]['device_key']
                device_type = input_devices[i]['type']
                samples_processed += 1
                if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                    log.debug('Comparing {}.{}={} ({}v) '
                              'to {} ({}) (tolerance: {})'.format(adc_name,
                                                                  pin,
                                                                  normalized_value,
                                                                  sampled_value,
                                                                  input_value,
                                                                  device_key,
                                                                  SAMPLE_DEVIATION_TOLERANCE))
                if abs(normalized_value - input_value) <= SAMPLE_DEVIATION_TOLERANCE:
                    if 'meter' in device_key.lower() and device_key in meter_history:
                        meter_value, meter_state = meter_history[device_key]
                        meter_history[device_key] = (meter_value, False)
                    # forget that this device was active
                    if device_key in device_history:
                        log.debug("'{}' is no longer active.".format(device_key))
                        del device_history[device_key]
                    # nothing else to unset here, next input now
                    continue

                # a device has now gone out of normal range

                if 'meter' in device_key.lower():
                    if device_key not in meter_history:
                        meter_history[device_key] = (1, True)
                    meter_value, meter_state = meter_history[device_key]
                    # latch
                    if not meter_state:
                        meter_history[device_key] = (meter_value+1, True)
                    if time.time() - meters_last_posted >= int(config.get('app', 'meter_sample_interval_seconds')):
                        meter_value, meter_state = meter_history[device_key]
                        log.debug('{} metered {}'.format(device_key, meter_value))
                        meters_last_posted = time.time()
                        meter_history[device_key] = (0, True)
                        input_device = copy.copy(input_devices[i])
                        input_device['sample_value'] = meter_value
                        active_devices.append(input_device)
                    else:
                        continue
                else:
                    device_event_distinction = device_key
                    output_samples[device_key] = int(normalized_value)
                    input_device = copy.copy(input_devices[i])
                    input_device['sample_value'] = int(normalized_value)
                    event_detail = None
                    if i in input_tamper_values:
                        tamper_value = int(input_tamper_values[i])
                        if abs(normalized_value - tamper_value) <= SAMPLE_DEVIATION_TOLERANCE:
                            event_detail = tamper_label
                            device_event_distinction = '{} {}'.format(device_key, tamper_label)
                    # decorate the alarm input type if it is not in a fault state
                    if device_type.lower() == 'alarm' and 'event_detail' not in input_device:
                        event_detail = str(alarm_decoder)
                    # now include the event detail
                    if event_detail:
                        input_device['event_detail'] = event_detail
                    # determine whether the value has changed
                    if device_key in device_history:
                        historic_value, sampled_at, historic_detail = device_history[device_key]
                        # has the value stayed the same?
                        if abs(normalized_value - historic_value) <= SAMPLE_DEVIATION_TOLERANCE and event_detail == historic_detail:
                            # sample to avoid log spam
                            if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                                log.debug("Debouncing '{}' activated {} seconds "
                                          "ago.".format(device_event_distinction,
                                                        int(time.time() - sampled_at)))
                            continue
                    # update the device history and treat as active
                    device_history[device_key] = (normalized_value, time.time(), event_detail)
                    # add the input device to the 'active' list
                    active_devices.append(input_device)
            if len(active_devices) > 0:
                uploader_socket.send_pyobj({
                    'samples': output_samples,
                    'active_devices': active_devices
                })
                last_upload = time.time()
            else:
                inactivity = time.time() - last_upload
                if inactivity > HEARTBEAT_INTERVAL_SECONDS:
                    uploader_socket.send_pyobj({
                        'statistics': {'sample_count': samples_processed},
                        'device_info': device_info
                    })
                    last_upload = time.time()
            sleep(SAMPLE_INTERVAL_SECONDS)
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated):
        alarm_decoder.stop()
        uploader_socket.close()
        zmq_context.term()
    finally:
        log.info('Removing PID file {}'.format(pidfile))
        os.unlink(pidfile)

    log.info('Exiting with code {}'.format(signal_handler.last_signal))
    # exit using the signal, if any
    sys.exit(signal_handler.last_signal)
