#!/usr/bin/python
import copy
import dateutil.parser
import json
import logging
import logging.handlers
import os
import pytz
import serial
import signal
import sys
import time
import umsgpack
import zmq

from ADCPi import ADCPi
from IOPi import IOPi

from configparser import ConfigParser

from datetime import datetime
from random import randint
from raven import Client as Sentry
from serial.serialutil import SerialException
from threading import Thread
from time import sleep
from zmq import ContextTerminated


APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# PID file check
pidfile = '/var/run/{}.pid'.format(APP)
mypid = os.getpid()
if os.path.isfile(pidfile):
    pid = None
    try:
        pid = int(open(pidfile, 'r').read())
    except ValueError:
        print('{} contains no valid PID, updating with {}'.format(pidfile, mypid))
    if pid is not None:
        message = '{} exists for PID {}.'.format(pidfile, pid)
        proc_path = '/proc/{}/cmdline'.format(pid)
        # existing process?
        if os.path.isfile(proc_path):
            proc_info = open(proc_path, 'r').read()
            # there is an existing process and may be this program
            if proc_info is not None and 'python' in proc_info and APP in proc_info and mypid != pid:
                print('{} is already running. {}'.format(APP, message))
                sys.exit(1)
# take control of PID file
open(pidfile, 'w').write(str(mypid))

log = logging.getLogger(APP)
# no console by default
log.propagate = False

# FIXME: benchmark this to supply voltage using test pin or something else
ADC_SAMPLE_MAX = 5.0
HEARTBEAT_INTERVAL_SECONDS = 5
RELAY_DEFAULT_ACTIVE_TIME_SECONDS = 1
SAMPLE_INTERVAL_SECONDS = 0.1
SAMPLE_DEVIATION_TOLERANCE = 10
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'
URL_WORKER_RELAY_CTRL = 'inproc://relay-ctrl'
URL_WORKER_RELAY = 'inproc://relay-{}'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)

sentry = Sentry()


def make_timestamp(timestamp=None, make_string=False):
    if timestamp is None:
        timestamp = datetime.utcnow()
    elif isinstance(timestamp, float):
        timestamp = datetime.utcfromtimestamp(timestamp)
    elif isinstance(timestamp, str):
        timestamp = dateutil.parser.parse(timestamp)
    if make_string:
        return timestamp.strftime(DATE_FORMAT)
    # not naive datetime
    return timestamp.replace(tzinfo=pytz.utc)


class AlarmDecoder(Thread):

    ZONE_DEBOUNCE_SECONDS = 2

    # Baseline:           0000000010100010001010101000001000000001010101010101010101010100
    # Ready:              0000000010100010001010101000001000000001010101010101010101010000
    # AC/LB + Ready:      0000000010100010001010101000001000000001010101010100010101010000
    # AC/LB + 1:          0000000010100010001010101000001000000000010101010100010101010100
    # AC/LB + Arm + Stay: 0000000010100010001010101000001000000001010101010100010000010100
    # AC/LB + 1:          0000000010100010001010101000001000000000010101010100010101010100
    # AC/LB + 2:          0000000010100010001010101000001000000001000101010100010101010100
    # 2:                  0000000010100010001010101000001000000001000101010101010101010100
    # AC/LB + 3:          0000000010100010001010101000001000000001010001010100010101010100
    # AC/LB + 4:          0000000010100010001010101000001000000001010100010100010101010100
    # AC/LB + 5:          0000000010100010001010101000001000000001010101000100010101010100
    # AC/LB + 6:          0000000010100010001010101000001000000001010101010000010101010100

    # 1111111111111111111111111111111111111110000000000000000000000000
    INPUT_MASK = 0xFFFFFFFFFE000000
    # 0000000000000000000000000000000000000001111111111111111111111111
    STATUS_MASK = 0x1FFFFFF
    # 0000000010100010001010101000001000000001010101010101010101010100
    BASELINE = 0xA22A8201555554
    # 0000000000000000000000000000000000000010101010101010101010101010
    STATUS_VALIDITY_MASK = 0x2AAAAAA
    # 1010101010101010101010101010101000000000000000000000000000000000
    INPUT_VALIDITY_MASK = 0xAAAAAAAA00000000
    # 0000000000000000000000000100000000000000000000101010000000000000
    USER_INPUT_1 = 0x4000000000
    # 0000000000000000000000000001000000000000000000000000100000000010
    USER_INPUT_2 = 0x1000000000
    # 0000000000000001000000000000000000000000000000000000000000000000
    USER_INPUT_3 = 0x1000000000000
    # 0000000000000000000001000000000000000000000000000000000010000000
    USER_INPUT_4 = 0x40000000000
    # 0000000000000000010000000000000000000000000000000000000000000000
    USER_INPUT_5 = 0x400000000000
    # 0000000000000000000000000000000100000000000000000000000000000000
    USER_INPUT_6 = 0x100000000
    # 0000000000000000000000010000000000000000000010000000000000000000
    USER_INPUT_7 = 0x10000000000
    # 0000000000000100000000000000000000000000000000000000000000000000
    USER_INPUT_8 = 0x4000000000000
    # 0000000000000000000100000000000000000000000000000000000000000000
    USER_INPUT_9 = 0x100000000000
    # 0000000000000000000000000000000010000000000000000000000000000000
    USER_INPUT_0 = 0x80000000
    # 0000000000010000000000000000000000000000001000000000000000000000
    USER_INPUT_AST = 0x10000000000000
    # 0000000001000000000000000000000000000000100000000000000000000000
    USER_INPUT_HASH = 0x40000000000000
    # 0000000000000000000000000000010000000000000000000000000000000000
    USER_INPUT_STAY = 0x400000000
    # 0000000000000000000000000000000000100000000000000000000000000000
    USER_INPUT_INSTANT = 0x20000000
    # 0100000000000000000000000000000000000000000000000000000000000000
    USER_INPUT_BYPASS = 0x4000000000000000
    # 0001010100000000000000000000000000000010000000000000000000000000
    USER_INPUT_CODE = 0x1500000000000000
    # 0000000000000000000100000000000000000000000000000000000000000000
    USER_INPUT_FIRE1 = 0x100000000000
    # 0000000000000000000000010000000000000000000010000000000000100000
    USER_INPUT_FIRE2 = 0x10000000000
    # 0000000000000001000000000000000000000000000000000000001000000000
    USER_INPUT_MED1 = 0x1000000000000
    # 0000000000000000000000000100000000000000000000101010000000001000
    USER_INPUT_MED2 = 0x4000000000
    # 0000000001000000000000000000000000000000100000000000000000000000
    USER_INPUT_POL1 = 0x40000000000000
    # 0000000000010000000000000000000000000000001000000000000000000000
    USER_INPUT_POL2 = 0x10000000000000

    # 0000000000000000000000000000000000000001000000000000000000000000
    ZONE_1 = 0x1000000
    # 0000000000000000000000000000000000000000010000000000000000000000
    ZONE_2 = 0x400000
    # 0000000000000000000000000000000000000000000100000000000000000000
    ZONE_3 = 0x100000
    # 0000000000000000000000000000000000000000000001000000000000000000
    ZONE_4 = 0x40000
    # 0000000000000000000000000000000000000000000000010000000000000000
    ZONE_5 = 0x10000
    # 0000000000000000000000000000000000000000000000000100000000000000
    ZONE_6 = 0x4000
    # 0000000000000000000000000000000000000000000000000001000000000000
    AC_LB = 0x1000
    # 0000000000000000000000000000000000000000000000000000010000000000
    #INSTANT = 0x400??
    # 0000000000000000000000000000000000000000000000000000000100000000
    ARM = 0x100
    # 0000000000000000000000000000000000000000000000000000000001000000
    STAY = 0x40
    # 0000000000000000000000000000000000000000000000000000000000010000
    #INSTANT = 0x10??
    # 0000000000000000000000000000000000000000000000000000000000000100
    READY = 0x4
    # 0000000000000000000000000000000000000000000000000000000000000001
    BUZZER = 0x1

    def __init__(self):
        super(AlarmDecoder, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        self._alarm_state = 0
        # serial
        self._com1 = serial.Serial(
            port=config.get('serial', 'port'),
            baudrate=config.getint('serial', 'baudrate'),
            timeout=1)
        # state init
        self._zone_states = dict()
        self._zone_states[AlarmDecoder.ARM] = \
        self._zone_states[AlarmDecoder.STAY] = \
        self._zone_states[AlarmDecoder.AC_LB] = \
        self._zone_states[AlarmDecoder.READY] = \
        self._zone_states[AlarmDecoder.ZONE_1] = \
        self._zone_states[AlarmDecoder.ZONE_2] = \
        self._zone_states[AlarmDecoder.ZONE_3] = \
        self._zone_states[AlarmDecoder.ZONE_4] = \
        self._zone_states[AlarmDecoder.ZONE_5] = \
        self._zone_states[AlarmDecoder.ZONE_6] = 0

    def run(self):
        while True:
            # serial data for the alarm device type
            try:
                alarm_state_data = self._com1.readline()
            except SerialException:
                if self._com1.closed:
                    log.error('{} is closed, cannot read serial data.'.format(config.get('serial', 'port')))
                    break
            if alarm_state_data is None:
                continue
            alarm_state_data = alarm_state_data.decode()
            if len(alarm_state_data) > 0:
                self.set_state(alarm_state_data)
            sleep(SAMPLE_INTERVAL_SECONDS)
            # throw away the intermediate data if the external sample rate exceeds our ability to consume it
            self._com1.flushInput()

    def stop(self):
        if not self._com1.closed:
            self._com1.close()

    def set_state(self, state_string):
        log.debug('{} setting alarm state to [{}]'.format(self.__class__.__name__, state_string))
        if state_string is None:
            return
        # trim
        state_string = state_string.rstrip()
        if len(state_string) == 0 or ':' not in state_string or ',' not in state_string:
            log.debug('Ignoring invalid alarm decoder word: [{}]'.format(state_string))
            return
        len_words = state_string.split(':')
        expect_len = int(len_words[0])
        word_string = len_words[1]
        if len(word_string) != expect_len:
            log.debug('Ignoring invalid alarm decoder word length, '
                      'expected {} but got {}: [{}]'.format(expect_len, len(word_string), state_string))
            return
        words = word_string.split(',')
        try:
            upper_word = int(words[0], base=16)
            lower_word = int(words[1], base=16)
        except ValueError:
            log.debug('Ignoring invalid alarm decoder word: [{}]'.format(words))
            return
        new_state_with_check_bits = (upper_word << 31) | lower_word
        new_state = AlarmDecoder.BASELINE ^ new_state_with_check_bits
        # word containing valid state change
        if (new_state & AlarmDecoder.STATUS_VALIDITY_MASK == 0) and (new_state != self._alarm_state):
            self._alarm_state = new_state
            # set the individual zone states
            now = time.time()
            if new_state & AlarmDecoder.ARM == AlarmDecoder.ARM:
                self._zone_states[AlarmDecoder.ARM] = now
            if new_state & AlarmDecoder.STAY == AlarmDecoder.STAY:
                self._zone_states[AlarmDecoder.STAY] = now
            if new_state & AlarmDecoder.AC_LB == AlarmDecoder.AC_LB:
                self._zone_states[AlarmDecoder.AC_LB] = now
            if new_state & AlarmDecoder.READY == AlarmDecoder.READY:
                self._zone_states[AlarmDecoder.READY] = now
            if new_state & AlarmDecoder.ZONE_1 == AlarmDecoder.ZONE_1:
                self._zone_states[AlarmDecoder.ZONE_1] = now
            if new_state & AlarmDecoder.ZONE_2 == AlarmDecoder.ZONE_2:
                self._zone_states[AlarmDecoder.ZONE_2] = now
            if new_state & AlarmDecoder.ZONE_3 == AlarmDecoder.ZONE_3:
                self._zone_states[AlarmDecoder.ZONE_3] = now
            if new_state & AlarmDecoder.ZONE_4 == AlarmDecoder.ZONE_4:
                self._zone_states[AlarmDecoder.ZONE_4] = now
            if new_state & AlarmDecoder.ZONE_5 == AlarmDecoder.ZONE_5:
                self._zone_states[AlarmDecoder.ZONE_5] = now
            if new_state & AlarmDecoder.ZONE_6 == AlarmDecoder.ZONE_6:
                self._zone_states[AlarmDecoder.ZONE_6] = now
            # debugging
            bin_string = '{0:b}'.format(new_state).zfill(64)
            log.debug('House alarm state has changed to: {}'.format(bin_string))
            to_string = str(self)
            if len(to_string) > 0:
                log.info('House alarm: {}'.format(to_string))
        elif new_state & AlarmDecoder.INPUT_VALIDITY_MASK == 0:
            user_input_string = 'House alarm: User input {}'
            if new_state & AlarmDecoder.USER_INPUT_0 == AlarmDecoder.USER_INPUT_0:
                log.debug(user_input_string.format('0'))
            if new_state & AlarmDecoder.USER_INPUT_1 == AlarmDecoder.USER_INPUT_1:
                log.debug(user_input_string.format('1'))
            if new_state & AlarmDecoder.USER_INPUT_2 == AlarmDecoder.USER_INPUT_2:
                log.debug(user_input_string.format('2'))
            if new_state & AlarmDecoder.USER_INPUT_3 == AlarmDecoder.USER_INPUT_3:
                log.debug(user_input_string.format('3'))
            if new_state & AlarmDecoder.USER_INPUT_4 == AlarmDecoder.USER_INPUT_4:
                log.debug(user_input_string.format('4'))
            if new_state & AlarmDecoder.USER_INPUT_5 == AlarmDecoder.USER_INPUT_5:
                log.debug(user_input_string.format('5'))
            if new_state & AlarmDecoder.USER_INPUT_6 == AlarmDecoder.USER_INPUT_6:
                log.debug(user_input_string.format('6'))
            if new_state & AlarmDecoder.USER_INPUT_7 == AlarmDecoder.USER_INPUT_7:
                log.debug(user_input_string.format('7'))
            if new_state & AlarmDecoder.USER_INPUT_8 == AlarmDecoder.USER_INPUT_8:
                log.debug(user_input_string.format('8'))
            if new_state & AlarmDecoder.USER_INPUT_9 == AlarmDecoder.USER_INPUT_9:
                log.debug(user_input_string.format('9'))
            if new_state & AlarmDecoder.USER_INPUT_AST == AlarmDecoder.USER_INPUT_AST:
                log.debug(user_input_string.format('*'))
            if new_state & AlarmDecoder.USER_INPUT_HASH == AlarmDecoder.USER_INPUT_HASH:
                log.debug(user_input_string.format('#'))
            if new_state & AlarmDecoder.USER_INPUT_STAY == AlarmDecoder.USER_INPUT_STAY:
                log.debug(user_input_string.format('STAY'))
            if new_state & AlarmDecoder.USER_INPUT_BYPASS == AlarmDecoder.USER_INPUT_BYPASS:
                log.debug(user_input_string.format('BYPASS'))
            if new_state & AlarmDecoder.USER_INPUT_INSTANT == AlarmDecoder.USER_INPUT_INSTANT:
                log.debug(user_input_string.format('INSTANT'))
            if new_state & AlarmDecoder.USER_INPUT_CODE == AlarmDecoder.USER_INPUT_CODE:
                log.debug(user_input_string.format('CODE'))
        else:
            bin_string = '{0:b}'.format(new_state).zfill(64)
            log.warning('Ignoring invalid alarm status word: {} derived from {} ({})'.format(bin_string, new_state_with_check_bits, state_string))
            return

    def __str__(self):
        zone_summary = list()
        now = time.time()
        if now - self._zone_states[AlarmDecoder.ZONE_1] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z1'))
        if now - self._zone_states[AlarmDecoder.ZONE_2] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z2'))
        if now - self._zone_states[AlarmDecoder.ZONE_3] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z3'))
        if now - self._zone_states[AlarmDecoder.ZONE_4] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z4'))
        if now - self._zone_states[AlarmDecoder.ZONE_5] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z5'))
        if now - self._zone_states[AlarmDecoder.ZONE_6] <= AlarmDecoder.ZONE_DEBOUNCE_SECONDS:
            zone_summary.append(config.get('house_alarm_decoder', 'Z6'))
        return ', '.join(zone_summary)


class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        # inproc socket to accept messages to publish
        # to the outside world
        self.inproc_pull = zmq_context.socket(zmq.PULL)
        self.inproc_pull.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                  port=config.get('zmq', 'pubsub_port')))
        while True:
            try:
                publisher.send(Uploader.make_payload(
                    timestamp=None,
                    data=self.inproc_pull.recv_pyobj()))
            except ContextTerminated:
                self.inproc_pull.close()
                publisher.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue

    @staticmethod
    def make_payload(timestamp=None, data=None):
        payload = {'timestamp': make_timestamp(timestamp, True)}
        if data is not None and len(data) > 0:
            payload['data'] = data
        log.debug(json.dumps(payload))
        return umsgpack.packb(payload)


class DeviceActivator(Thread):

    def __init__(self):
        super(DeviceActivator, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.listener = zmq_context.socket(zmq.PULL)
        # what to do with device activations
        self.relay_control = zmq_context.socket(zmq.PUSH)

    def run(self):
        # outputs
        self.relay_control.connect(URL_WORKER_RELAY_CTRL)
        # Socket to talk to the outside world
        self.listener.bind('tcp://{ip}:{port}'.format(ip=config.get('app', 'eth0_ip'),
                                                      port=config.get('zmq', 'pushpull_port')))
        while True:
            try:
                event = umsgpack.unpackb(self.listener.recv())
                log.debug(event)
                if 'data' not in event:
                    log.warning('Unknown event data: {}'.format(event))
                    continue
                event_data = event['data']
                if 'trigger_output' in event_data:
                    output_type = event_data['trigger_output']['type']
                    if 'input_context' not in event_data:
                        log.warning('{} requested without context, ignoring.'.format(output_type))
                        continue
                    delay = None
                    if 'trigger_duration' in event_data:
                        delay = event_data['trigger_duration']
                    # send all output activations to the relay control, which will filter accordingly
                    self.relay_control.send_pyobj((event_data['trigger_output']['device_key'], delay))
            except ContextTerminated:
                self.listener.close()
                self.relay_control.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue


class Relay(Thread):

    def __init__(self, relay_name, io, pin):
        super(Relay, self).__init__()
        self.daemon = True
        self._name = relay_name
        self._io = io
        self._pin = pin
        self._zmq_url = URL_WORKER_RELAY.format(relay_name)
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(self._zmq_url)

    @property
    def zmq_url(self):
        return self._zmq_url

    def run(self):
        while True:
            try:
                relay_ctrl = self.socket.recv_pyobj()
                if 'state' in relay_ctrl:
                    if relay_ctrl['state'] is True:
                        self._io.write_pin(self._pin, 1)
                        # sleep
                        if 'delay' in relay_ctrl:
                            delay = relay_ctrl['delay']
                        else:
                            delay = RELAY_DEFAULT_ACTIVE_TIME_SECONDS
                        log.info("Activating {} for {} seconds.".format(self._name, delay))
                        self._io.write_pin(self._pin, 1)
                        sleep(float(delay))
                    self._io.write_pin(self._pin, 0)
            except ContextTerminated:
                self.socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue


class RelayControl(Thread):

    def __init__(self, relay_mappings):
        super(RelayControl, self).__init__()
        self.daemon = True
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_RELAY_CTRL)
        # Push socket to control relays
        self._sockets = dict()
        for relay, worker_url in list(relay_mappings.items()):
            socket = zmq_context.socket(zmq.PUSH)
            self._sockets[relay] = socket
            socket.connect(worker_url)
        self._output_to_relay = dict()

    def run(self):
        while True:
            try:
                device_key, delay = self.socket.recv_pyobj()
                log.debug("Relay event for '{}'".format(device_key))
                if device_key not in self._output_to_relay:
                    log.debug("'{}' is not configured for relay control".format(device_key))
                    continue
                relay = self._output_to_relay[device_key]
                if relay in self._sockets:
                    log.info("'{}' => '{}'".format(device_key, relay))
                    relay_cmd = {
                        'state': True
                    }
                    if delay:
                        relay_cmd['delay'] = delay
                    self._sockets[relay].send_pyobj(relay_cmd)
                else:
                    log.error("'{}' refers to non-existent relay '{}'".format(device_key, relay))
            except ContextTerminated:
                self.socket.close()
                for socket in list(self._sockets.values()):
                    socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue

    def add_output(self, device_key, relay):
        if device_key in self._output_to_relay:
            raise RuntimeError('{} is already associated with {}. Cannot also associate {}.'.format(
                device_key,
                self._output_to_relay[device_key],
                relay))
        self._output_to_relay[device_key] = relay


class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warning('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warning('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.INFO)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)

    # process configuration
    adcs = dict()
    for adc, address in config.items('adc_address'):
        log.info("Configuring '{}' @ '{}'".format(adc, address))
        address = address.split(',')
        adcs[adc] = ADCPi(int(address[0], 16),
                          int(address[1], 16),
                          12)

    ios = dict()
    for io, address in config.items('io_address'):
        log.info("Configuring '{}' @ '{}'".format(io, address))
        io_port = IOPi(int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    for relay, address in config.items('relay_address'):
        io, pin = tuple(address.split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.info("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    relay_workers = list()
    relay_to_worker = dict()
    # start relays
    for relay_name in list(relay_to_io.keys()):
        io, pin = relay_to_io[relay_name]
        relay = Relay(relay_name=relay_name, io=ios[io], pin=pin)
        relay.start()
        relay_workers.append(relay)
        relay_to_worker[relay_name] = relay.zmq_url

    relay_control = RelayControl(relay_mappings=relay_to_worker)

    input_types = dict(config.items('input_type'))
    # name overrides location name
    input_names = dict(config.items('input_name'))
    input_locations = dict(config.items('input_location'))
    # construct the device representation
    input_devices = dict()
    output_types = dict(config.items('output_type'))
    output_locations = dict(config.items('output_location'))
    device_info = dict()
    device_info['inputs'] = list()
    for field, input_type in list(input_types.items()):
        input_name = input_names[field]
        input_location = input_locations[field]
        device_description = {
            'name': input_name,
            'type': input_type,
            'location': input_location,
            'device_key': '{} {} ({})'.format(input_name, input_type, input_location),
            'device_label': '{} {}'.format(input_name, input_type)
        }
        device_info['inputs'].append(device_description)
        input_devices[field] = device_description
    device_info['outputs'] = list()
    for field, output_type in list(output_types.items()):
        output_location = output_locations[field]
        device_key = '{} {}'.format(output_location, output_type)
        device_info['outputs'].append({
            'type': output_type,
            'location': output_location,
            'device_key': device_key
        })
        if config.has_option('output_relay', field):
            relay = config.get('output_relay', field)
            log.info("'{}' will trigger '{}'".format(device_key, relay))
            relay_control.add_output(
                device_key=device_key,
                relay=relay)

    input_addresses = dict(config.items('input_address'))
    input_to_adc = dict()
    for field in input_addresses:
        adc, pin = tuple(input_addresses[field].split(':'))
        input_to_adc[field] = (adc, int(pin))
        # get the normal value
        log.info("ADC {} pin {} will detect '{}'".format(adc, pin, input_devices[field]['device_key']))

    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)

    # start relay control
    relay_control.start()

    device_activator = DeviceActivator()
    device_activator.start()

    # alarm decoder
    alarm_decoder = AlarmDecoder()
    alarm_decoder.start()

    samples_processed = 0

    input_normal_values = dict(config.items('input_normal_values'))
    tamper_label = config.get('app', 'tamper_label')
    input_tamper_values = dict(config.items('input_tamper_values'))

    # set up signal handlers
    signal_handler = SignalHandler()

    try:
        last_upload = 0
        device_history = dict()
        while True:
            active_devices = list()
            output_samples = dict()
            for i in list(input_to_adc.keys()):
                adc_name, pin = input_to_adc[i]
                sampled_value = adcs[adc_name].read_voltage(pin)
                normalized_value = (sampled_value / ADC_SAMPLE_MAX) * 100
                input_value = int(input_normal_values[i])
                device_key = input_devices[i]['device_key']
                device_type = input_devices[i]['type']
                samples_processed += 1
                if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                    log.debug('Comparing {}.{}={} ({}v) '
                              'to {} ({}) (tolerance: {})'.format(adc_name,
                                                                  pin,
                                                                  normalized_value,
                                                                  sampled_value,
                                                                  input_value,
                                                                  device_key,
                                                                  SAMPLE_DEVIATION_TOLERANCE))
                if abs(normalized_value - input_value) <= SAMPLE_DEVIATION_TOLERANCE:
                    # forget that this device was active
                    if device_key in device_history:
                        log.debug("'{}' is no longer active.".format(device_key))
                        del device_history[device_key]
                    # nothing else to unset here, next input now
                    continue

                # a device has now gone out of normal range
                device_event_distinction = device_key
                output_samples[device_key] = int(normalized_value)
                input_device = copy.copy(input_devices[i])
                input_device['sample_value'] = int(normalized_value)
                event_detail = None
                if i in input_tamper_values:
                    tamper_value = int(input_tamper_values[i])
                    if abs(normalized_value - tamper_value) <= SAMPLE_DEVIATION_TOLERANCE:
                        event_detail = tamper_label
                        device_event_distinction = '{} {}'.format(device_key, tamper_label)
                # decorate the alarm input type if it is not in a fault state
                if device_type.lower() == 'alarm':
                    event_detail = str(alarm_decoder)
                # now include the event detail
                if event_detail:
                    input_device['event_detail'] = event_detail
                # determine whether the value has changed
                if device_key in device_history:
                    historic_value, sampled_at, historic_detail = device_history[device_key]
                    # has the value stayed the same?
                    if abs(normalized_value - historic_value) <= SAMPLE_DEVIATION_TOLERANCE and event_detail == historic_detail:
                        # sample to avoid log spam
                        if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                            log.debug("Debouncing '{}' (detail: {}) activated {} seconds "
                                      "ago.".format(device_event_distinction, event_detail,
                                                    int(time.time() - sampled_at)))
                        continue
                # update the device history and treat as active
                device_history[device_key] = (normalized_value, time.time(), event_detail)
                # add the input device to the 'active' list
                active_devices.append(input_device)
                log.info("'{}' (detail: {}, sampled: {})".format(device_event_distinction, event_detail, normalized_value))
            if len(active_devices) > 0:
                uploader_socket.send_pyobj({
                    'samples': output_samples,
                    'active_devices': active_devices
                })
                last_upload = time.time()
            else:
                inactivity = time.time() - last_upload
                if inactivity > HEARTBEAT_INTERVAL_SECONDS:
                    uploader_socket.send_pyobj({
                        'statistics': {'sample_count': samples_processed},
                        'device_info': device_info
                    })
                    last_upload = time.time()
            sleep(SAMPLE_INTERVAL_SECONDS)
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated):
        alarm_decoder.stop()
        uploader_socket.close()
        zmq_context.term()
    finally:
        log.info('Removing PID file {}'.format(pidfile))
        os.unlink(pidfile)

    log.info('Exiting with code {}'.format(signal_handler.last_signal))
    # exit using the signal, if any
    sys.exit(signal_handler.last_signal)
