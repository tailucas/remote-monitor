#!/usr/bin/env python
import boto3
import builtins
import copy
import dateutil.parser
import json
import logging
import logging.handlers
import netifaces
import os
import pytz
import sentry_sdk
import signal
import sys
import threading
import time
import umsgpack
import zmq

from ADCPi import ADCPi # type: ignore
from IOPi import IOPi # type: ignore

from configparser import ConfigParser

from datetime import datetime
from pathlib import Path
from random import randint
from sentry_sdk import capture_exception
from threading import Thread
from time import sleep
from traceback import StackSummary
from zmq import ContextTerminated
from zmq.error import ZMQError

import botocore
import os.path
from botoflow import activity, \
    activities, \
    execute, \
    return_, \
    workflow_starter, \
    WorkflowDefinition, \
    ThreadedWorkflowExecutor, \
    ThreadedActivityExecutor
from botoflow.workers.workflow_worker import WorkflowWorker
from botoflow.workers.activity_worker import ActivityWorker
from botoflow.constants import SECONDS, MINUTES
from botoflow.exceptions import ActivityTaskFailedError, \
    WorkflowFailedError, WorkflowTimedOutError


builtins.APP_NAME = Path(__file__).stem
builtins.SENTRY_EXTRAS = []
AWS_REGION = os.environ['AWS_DEFAULT_REGION']
class CredsConfig:
    sentry_dsn: f'opitem:"Sentry" opfield:{APP_NAME}.dsn' = None # type: ignore
    aws_akid: f'opitem:"AWS" opfield:{AWS_REGION}.akid' = None # type: ignore
    aws_sak: f'opitem:"AWS" opfield:{AWS_REGION}.sak' = None # type: ignore
# instantiate class
builtins.creds_config = CredsConfig()

import pylib

from pylib.bluetooth import bluetooth_init, ping_bluetooth_devices
from pylib.datetime import is_list, make_timestamp, parse_datetime
from pylib.data import make_payload
from pylib.aws import boto_session, \
    swf_region, \
    swf_domain
from pylib.aws.metrics import post_count_metric
from pylib.aws.swf import SWFActivityWaiter, \
    swf_exception_handler, \
    IOBoardActivity, \
    DeviceInfoActivity, \
    DeviceWorkflow, \
    IOBoardWorkflow
from pylib.process import SignalHandler, exec_cmd
from pylib import threads
from pylib.threads import thread_nanny
from pylib.zmq import AppPuller, Publisher

# expose builtins for lint-friendly
log = builtins.log
APP_CONFIG = builtins.APP_CONFIG
zmq_context = builtins.zmq_context
APP_NAME = builtins.APP_NAME
DEVICE_NAME = builtins.DEVICE_NAME

# FIXME: benchmark this to supply voltage using test pin or something else
ADC_SAMPLE_MAX = 5.0
HEARTBEAT_INTERVAL_SECONDS = 5
RELAY_DEFAULT_ACTIVE_TIME_SECONDS = 1
SAMPLE_INTERVAL_SECONDS = 0.1
SAMPLE_DEVIATION_TOLERANCE = 10
URL_WORKER_RELAY_CTRL = 'inproc://relay-ctrl'
URL_WORKER_RELAY = 'inproc://relay-{}'


class Relay(Thread):

    def __init__(self, relay_name, io, pin):
        super(Relay, self).__init__()
        self.daemon = True
        self._name = relay_name
        self._io = io
        self._pin = pin
        self._zmq_url = URL_WORKER_RELAY.format(relay_name)
        self.socket = zmq_context.socket(zmq.PULL) # type: ignore
        self.socket.bind(self._zmq_url)

    @property
    def zmq_url(self):
        return self._zmq_url

    def run(self):
        while True:
            try:
                relay_ctrl = self.socket.recv_pyobj()
                if 'state' in relay_ctrl:
                    if relay_ctrl['state'] is True:
                        self._io.write_pin(self._pin, 1)
                        # sleep
                        if 'duration' in relay_ctrl:
                            duration = relay_ctrl['duration']
                        else:
                            duration = RELAY_DEFAULT_ACTIVE_TIME_SECONDS
                        log.info("Activating {} for {} seconds.".format(self._name, duration))
                        self._io.write_pin(self._pin, 1)
                        sleep(float(duration))
                    self._io.write_pin(self._pin, 0)
            except ContextTerminated:
                self.socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
                continue


class RelayControl(Thread):

    def __init__(self, relay_mappings):
        super(RelayControl, self).__init__()
        self.daemon = True
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_RELAY_CTRL)
        # Push socket to control relays
        self._sockets = dict()
        for relay, worker_url in list(relay_mappings.items()):
            socket = zmq_context.socket(zmq.PUSH) # type: ignore
            self._sockets[relay] = socket
            socket.connect(worker_url)
        self._output_to_relay = dict()

    def run(self):
        while True:
            try:
                device_key, duration = self.socket.recv_pyobj()
                log.debug("Relay event for '{}'".format(device_key))
                if device_key not in self._output_to_relay:
                    log.debug("'{}' is not configured for relay control".format(device_key))
                    continue
                relay = self._output_to_relay[device_key]
                if relay in self._sockets:
                    log.info("'{}' => '{}'".format(device_key, relay))
                    relay_cmd = {
                        'state': True
                    }
                    if duration:
                        relay_cmd['duration'] = duration
                    self._sockets[relay].send_pyobj(relay_cmd)
                else:
                    log.error("'{}' refers to non-existent relay '{}'".format(device_key, relay))
                    post_count_metric('Errors')
            except ContextTerminated:
                self.socket.close()
                for socket in list(self._sockets.values()):
                    socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
                continue

    def add_output(self, device_key, relay):
        if device_key in self._output_to_relay:
            raise RuntimeError('{} is already associated with {}. Cannot also associate {}.'.format(
                device_key,
                self._output_to_relay[device_key],
                relay))
        self._output_to_relay[device_key] = relay


if __name__ == "__main__":
    # connect to SWF
    swf_activity = IOBoardActivity(URL_WORKER_RELAY_CTRL)
    swf_worker = ThreadedActivityExecutor(ActivityWorker(boto_session,
                                            swf_region,
                                            swf_domain,
                                            APP_NAME,
                                            swf_activity, DeviceInfoActivity()))
    swf_worker._worker.unhandled_exception_handler = swf_exception_handler
    swf_worker.start()

    # process configuration
    adcs = dict()
    for adc, address in APP_CONFIG.items('adc_address'):
        log.info("Configuring '{}' @ '{}'".format(adc, address))
        address = address.split(',')
        adcs[adc] = ADCPi(int(address[0], 16),
                          int(address[1], 16),
                          12)

    ios = dict()
    for io, address in APP_CONFIG.items('io_address'):
        log.info("Configuring '{}' @ '{}'".format(io, address))
        io_port = IOPi(int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    for relay, address in APP_CONFIG.items('relay_address'):
        io, pin = tuple(address.split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.info("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    relay_workers = list()
    relay_to_worker = dict()
    # start relays
    for relay_name in list(relay_to_io.keys()):
        io, pin = relay_to_io[relay_name]
        relay = Relay(relay_name=relay_name, io=ios[io], pin=pin)
        relay.start()
        threads.threads_tracked.add(relay.getName())
        relay_workers.append(relay)
        relay_to_worker[relay_name] = relay.zmq_url

    relay_control = RelayControl(relay_mappings=relay_to_worker)

    input_types = dict(APP_CONFIG.items('input_type'))
    # name overrides location name
    input_names = dict(APP_CONFIG.items('input_name'))
    input_locations = dict(APP_CONFIG.items('input_location'))
    # construct the device representation
    input_devices = dict()
    output_types = dict(APP_CONFIG.items('output_type'))
    output_locations = dict(APP_CONFIG.items('output_location'))
    device_info = dict()
    device_info['inputs'] = list()
    for field, input_type in list(input_types.items()):
        input_name = input_names[field]
        input_location = input_locations[field]
        device_description = {
            'name': input_name,
            'type': input_type,
            'location': input_location,
            'device_key': '{} {} ({})'.format(input_name, input_type, input_location),
            'device_label': '{} {}'.format(input_name, input_type)
        }
        device_info['inputs'].append(device_description)
        input_devices[field] = device_description
    device_info['outputs'] = list()
    for field, output_type in list(output_types.items()):
        output_location = output_locations[field]
        device_key = '{} {}'.format(output_location, output_type)
        device_info['outputs'].append({
            'type': output_type,
            'location': output_location,
            'device_key': device_key
        })
        if APP_CONFIG.has_option('output_relay', field):
            relay = APP_CONFIG.get('output_relay', field)
            log.info("'{}' will trigger '{}'".format(device_key, relay))
            relay_control.add_output(
                device_key=device_key,
                relay=relay)

    input_addresses = dict(APP_CONFIG.items('input_address'))
    input_to_adc = dict()
    for field in input_addresses:
        adc, pin = tuple(input_addresses[field].split(':'))
        input_to_adc[field] = (adc, int(pin))
        # get the normal value
        log.info("ADC {} pin {} will detect '{}'".format(adc, pin, input_devices[field]['device_key']))

    # start up threads
    publisher = Publisher(
        zmq_context=zmq_context,
        zmq_ipc_url=URL_WORKER_PUBLISHER, # type: ignore
        pub_ip=APP_CONFIG.get('app', 'eth0_ip'),
        pub_port=APP_CONFIG.get('zmq', 'pubsub_port'))
    publisher.start()
    threads.threads_tracked.add(publisher.getName())
    publisher_socket = zmq_context.socket(zmq.PUSH) # type: ignore
    publisher_socket.connect(URL_WORKER_PUBLISHER) # type: ignore

    # start relay control
    relay_control.start()
    threads.threads_tracked.add(relay_control.getName())

    samples_processed = 0

    input_normal_values = dict(APP_CONFIG.items('input_normal_values'))
    tamper_label = APP_CONFIG.get('app', 'tamper_label')
    input_tamper_values = dict(APP_CONFIG.items('input_tamper_values'))

    # must be main thread
    signal_handler = SignalHandler()
    # start the nanny
    f = threading.Thread(name='nanny', target=thread_nanny, args=(signal_handler,))
    f.setDaemon(True)
    f.start()

    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        last_upload = 0
        device_history = dict()
        while not threads.shutting_down:
            active_devices = list()
            output_samples = dict()
            for i in list(input_to_adc.keys()):
                adc_name, pin = input_to_adc[i]
                try:
                    sampled_value = adcs[adc_name].read_voltage(pin)
                except TimeoutError:
                    log.warning('Timeout reading value from {} on pin {}.'.format(adc_name, pin), exc_info=1)
                    sleep(1)
                    continue
                normalized_value = (sampled_value / ADC_SAMPLE_MAX) * 100
                input_value = int(input_normal_values[i])
                device_key = input_devices[i]['device_key']
                device_type = input_devices[i]['type']
                samples_processed += 1
                if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                    log.debug('Comparing {}.{}={} ({}v) '
                              'to {} ({}) (tolerance: {})'.format(adc_name,
                                                                  pin,
                                                                  normalized_value,
                                                                  sampled_value,
                                                                  input_value,
                                                                  device_key,
                                                                  SAMPLE_DEVIATION_TOLERANCE))
                if abs(normalized_value - input_value) <= SAMPLE_DEVIATION_TOLERANCE:
                    # forget that this device was active
                    if device_key in device_history:
                        log.debug("'{}' is no longer active.".format(device_key))
                        del device_history[device_key]
                    # nothing else to unset here, next input now
                    continue

                # a device has now gone out of normal range
                device_event_distinction = device_key
                output_samples[device_key] = int(normalized_value)
                input_device = copy.copy(input_devices[i])
                input_device['sample_value'] = int(normalized_value)
                event_detail = None
                if i in input_tamper_values:
                    tamper_value = int(input_tamper_values[i])
                    if abs(normalized_value - tamper_value) <= SAMPLE_DEVIATION_TOLERANCE:
                        event_detail = tamper_label
                        device_event_distinction = '{} {}'.format(device_key, tamper_label)
                # now include the event detail
                if event_detail:
                    input_device['event_detail'] = event_detail
                # determine whether the value has changed
                if device_key in device_history:
                    historic_value, sampled_at, historic_detail = device_history[device_key]
                    # has the value stayed the same?
                    if abs(normalized_value - historic_value) <= SAMPLE_DEVIATION_TOLERANCE and event_detail == historic_detail:
                        # sample to avoid log spam
                        if randint(0, 1000) < SAMPLE_INTERVAL_SECONDS * 1000:
                            log.debug("Debouncing '{}' (detail: {}) activated {} seconds "
                                      "ago.".format(device_event_distinction, event_detail,
                                                    int(time.time() - sampled_at)))
                        continue
                # update the device history and treat as active
                device_history[device_key] = (normalized_value, time.time(), event_detail)
                # add the input device to the 'active' list
                active_devices.append(input_device)
                log.info("'{}' (detail: {}, sampled: {})".format(device_event_distinction, event_detail, normalized_value))
            if len(active_devices) > 0:
                publisher_socket.send_pyobj({
                    'samples': output_samples,
                    'active_devices': active_devices
                })
                last_upload = time.time()
            else:
                inactivity = time.time() - last_upload
                if inactivity > HEARTBEAT_INTERVAL_SECONDS:
                    publisher_socket.send_pyobj({
                        'statistics': {'sample_count': samples_processed},
                        'device_info': device_info
                    })
                    last_upload = time.time()
            sleep(SAMPLE_INTERVAL_SECONDS)
        raise RuntimeWarning("Shutting down...")
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated) as e:
        log.warning(str(e))
        threads.shutting_down = True
        threads.interruptable_sleep.set()
        message = "Shutting down {}..."
        log.info(message.format('SWF activity worker'))
        swf_worker.stop()
        log.info(message.format('SWF activity channel'))
        # stop SWF activity to close ZMQ channel
        swf_activity.stop()
        log.info(message.format('ZMQ publisher'))
        publisher_socket.close()
        log.info(message.format('ZMQ context'))
        zmq_context.term()
        log.info(message.format('SWF worker'))
        swf_worker.join()
        log.info('Shutdown complete.')