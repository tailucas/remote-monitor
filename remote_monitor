#!/usr/bin/python
import json
import logging
import logging.handlers
import os
import pprint
import pytz
import sys
import time
import umsgpack
import zmq

from ABE_helpers import ABEHelpers
from ABE_ADCPi import ADCPi
from ABE_IoPi import IoPi

from ConfigParser import ConfigParser

from datetime import datetime
from threading import Thread
from time import sleep
from zmq import ContextTerminated

sys.displayhook = pprint.pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)

UPLOAD_TIMEOUT_SECONDS = 1
HEARTBEAT_INTERVAL_SECONDS = 5
SAMPLE_INTERVAL_SECONDS = 1
RELAY_ON_TIME_SECONDS = 2
DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'
URL_WORKER_UPLOADER = 'inproc://uploader'


config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

zmq_context = zmq.Context()


class RelayControl(Thread):

    def __init__(self, relay_mappings, ios):
        super(RelayControl, self).__init__()
        self.daemon = True
        # IO control
        self._relay_mappings = relay_mappings
        self._ios = ios
        # Pull socket to receive relay control commands
        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind('tcp://*:{port}'.format(port=config.get('zmq', 'port')))

    def run(self):
        while True:
            try:
                data = umsgpack.unpackb(self.socket.recv())
                if data and 'relays' in data:
                    relays_to_activate = data['relays']
                    for relay in relays_to_activate:
                        if relay in self._relay_mappings:
                            io_name, pin = self._relay_mappings[relay]
                            log.debug('Activating {} on {}, pin {}'.format(relay, io_name, pin))
                            self._ios[io_name].write_pin(pin, 1)
                    #TODO remove
                    sleep(RELAY_ON_TIME_SECONDS)
                    # zero again
                    for io in self._ios.values():
                        io.write_port(0, 0x00)
                        io.write_port(1, 0x00)
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class Uploader(Thread):

    def __init__(self):
        super(Uploader, self).__init__()
        self.daemon = True
        # Socket to talk to accept samples
        self.samples = zmq_context.socket(zmq.PULL)
        self.samples.bind(URL_WORKER_UPLOADER)

    def run(self):
        # Socket to talk to the outside world
        publisher = zmq_context.socket(zmq.PUB)
        publisher.bind('tcp://*:{port}'.format(port=config.get('zmq', 'port')))
        while True:
            try:
                publisher.send(self.samples.recv())
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = time.time()
    payload['timestamp'] = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
    payload['location'] = '#YOLO'
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)

    # i2c
    i2c_bus = ABEHelpers().get_smbus()

    # process configuration
    adcs = dict()
    adc_count = int(config.get('app', 'adc_count'))
    for nr in range(1, adc_count+1):
        adc = 'adc{}'.format(nr)
        adc_address = config.get('adc_address', adc).split(',')
        log.debug("Configuring '{}' @ '{}'".format(adc, adc_address))
        adcs[adc] = ADCPi(i2c_bus,
                          int(adc_address[0], 16),
                          int(adc_address[1], 16),
                          12)

    ios = dict()
    io_count = int(config.get('app', 'io_count'))
    for nr in range(1, io_count+1):
        io = 'io{}'.format(nr)
        address = config.get('io_address', io)
        log.debug("Configuring '{}' @ '{}'".format(io, address))
        io_port = IoPi(i2c_bus,
                       int(address, 16))
        # set port direction to output
        io_port.set_port_direction(0, 0x00)
        io_port.set_port_direction(1, 0x00)
        # zero all pins
        io_port.write_port(0, 0x00)
        io_port.write_port(1, 0x00)
        ios[io] = io_port

    relay_to_io = dict()
    relay_count = int(config.get('app', 'relay_count'))
    for nr in range(1, relay_count+1):
        relay = 'relay{}'.format(nr)
        io, pin = tuple(config.get('relay_address', relay).split(':'))
        relay_to_io[relay] = (io, int(pin))
        log.debug("Mapped '{}' to IO '{}' on pin {}".format(relay, io, pin))

    detector_to_adc = dict()
    field_labels = dict()
    field_normal_values = dict()
    field_active_values = dict()
    detector_count = int(config.get('app', 'detector_count'))
    for nr in range(1, detector_count+1):
        detector = 'd{}'.format(nr)
        adc, pin = tuple(config.get('detector_address', detector).split(':'))
        detector_to_adc[detector] = (adc, int(pin))
        label = config.get('field_labels', detector)
        field_labels[detector] = label
        field_normal_values[detector] = int(config.get('field_normal_values', detector))
        field_active_values[detector] = int(config.get('field_active_values', detector))
        log.debug("Mapped detector '{}' as '{}' to ADC '{}' on pin {}".format(detector, label, adc, pin))

    # start up threads
    uploader = Uploader()
    uploader.start()
    uploader_socket = zmq_context.socket(zmq.PUSH)
    uploader_socket.connect(URL_WORKER_UPLOADER)

    relay_control = RelayControl(relay_mappings=relay_to_io, ios=ios)
    relay_control.start()

    try:
        while True:
            for adc_name, adc in adcs.items():
                for i in range(1, 9):
                    log.debug('{}, pin {}: {}'.format(adc_name, i, adc.read_raw(i)))
            sleep(60)
    except(KeyboardInterrupt, SystemExit):
        log.info('Closing message queues...')
        uploader_socket.close()
        relay_control.close()
        log.info('Terminating messaging context...')
        zmq_context.term()